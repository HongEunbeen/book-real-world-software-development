# 5장 비즈니스 규칙 엔진

## 도전 과제
- 모든 비즈니스 기능이 어떤 조건에 따라 액션을 유발하는 규칙을 정의할 수 있어야 한다는 사실을 알게되어 비즈니스 팀과 기술팀이 비즈니스 규칙 엔진을 직접 구현하기로 했다.

## 비즈니스 규칙 엔진 요구 사항
비즈니스 규칙 엔진은 간단한 맞춤 언어를 사용해 한 개 이상의 비즈니스 규칙을 실행하는 소프트웨어로 다양한 컴포넌트로 동시에 지원한다.
- 팩트 : 규칙이 활인할 수 있는 정보
- 액션 : 수행하려는 동작
- 조건 : 액션을 언제 발생시킬지 지정
- 규칙 : 실행하려는 비즈니스 규칙을 저정, 보통 팩트, 액션, 조건을 한 그룹으로 묶어 규칙으로 만듬

## 테스트 주도 개발
- 액션 추가
- 액션 실행
- 기본 보고

기본 기능을 기본 API로 변경한 후 실행할 수 있는 코드로 액션을 만든다.

이때, Runnable 인터페이스를 사용하는 방법도 있지만 도메인을 반영해 Action이라는 인터페이스를 만들어 비즈니스 규칙 엔진과 구체적 액션의 결합을 제거하는게 좋다.

Action 인터페이스는 한 개의 추상 메서드만 선언하므로 함수형 인터페이스 애너테이션을 추가할 수 있다.

### TDD를 사용하는 이유
- 테스트를 따로 구현하므로 테스트에 대응하는 요구 사항을 한 개씩 구현할 때마다 필요한 요구사항에 집중하고 개선 가능
- 코드를 올바르게 조직할 수 있다.(테스트를 구현하며 코드에 어떤 공개 인터페이스를 만들어야 하는지 검토 가능)
- TDD 주기에 따라 요구 사항 구현을 반복하며 종합적인 테스트 스위트 완성으로 요구사항 만족 및 버그 발생 범위 줄어듬
- 테스트 통과 위한 코드 구현으로 필요 없는 테스트 구현을 줄일 수 있음

### TDD 주기
1. 실패하는 테스트 구현
2. 모든 테스트 실행
3. 기능이 동작하도록 코드 구현
4. 모든 테스트 실행

-> 리팩터링이 추가되면 모든 테스트 실행 후 리팩터링을 한다.

## 모킹
모킹은 비즈니스 규칙에 액션을 추가할 때마다 실행되었는지 확인한다.

자바의 유명한 모킹 라이브러리인 모키토를 이용해 모킹을 사용한다.
1. 목 생성
2. 메서드가 호출되었는지 확인

정적 메서드 `mock()`으로 필요한 목 객체를 만드록 특정 동작이 실행되었는지 확인합니다.

```Java
final Action mockAction = mock(Action.class);
```
mock()메서드에 Action 객체를 인수로 전달해 유닛 테스트로 Action의 목 객체를 만듬

- 모키토를 이용해 메서드가 몇 번 호출되었는지, 어떤 인수가 제공되었는지 등 조금 더 복잡한 검증 로직도 실행할 수 있다.

## 조건 추가하기
비즈니스 구칙 엔진으로 특정 조건을 만족하면 액션을 수행하도록 설정할 수 있어야 함

비즈니스 규칙 엔진 내의 액션에서 사용할 수 있는 상태로 캡슐화해야 한다.

### 최신 자바 기능 두 가지
- 지역 변수 형식 추론
- switch문

#### 지역 변수 형식 추론
형식추론이란 컴파일러가 정적 형식을 자동으로 추론해 결정하는 기능으로 사용자는 더 이상 명시적으로 형식을 저장할 필요가 없다.

- 자바 7의 다이아몬드 연산자 기능
- 자바 10의 지역변수 형식 추론 (var 키워드) 

1. 자바 7의 다이아몬드 연산자
```java
Map<String, String> facts = new HashMap<>();

Map<String, String> facts = new HashMap<String, String>();
```
위 둘의 코드는 같은 코드를 나타낸다.

다이아몬드 연산자 기능은 개발자는 콘텍스트에서 파라미터 형식을 알 ㅜㅅ 있는 상황이라면 제네릭의 형식 파라미터를 생략할 수 있다.

2. 자바 10의 지역변수 형식 추론(var 키워드)

자바 10 부터는 형식 추론이 지역변수까지 확장되어 var 키워드와 형식추론으로 구현할 수 있다.
```java
Facts env = new Facts();

var env = new Facts();
```

형식 추론을 이용하면 자바 코드 구현 시간을 단축시킬 수 있지만 var를 이용한 이득은 주관적이기에 만약, 사용해도 가독성에 문제가 없다면 사용해도 좋지만 그렇지 않는다면 사용하지 않는것이 좋다.

#### 폴스루를 방지하는 swith문
자바 12에서는 새로운 switch문을 이용해 여러 break문을 사용하지 고도 폴스루를 방지할 수 있다.

새로운 switch문을 이용하면 가독성이 좋아질 뿐만 아니라 모든 가능성을 확인하는 소모 검사도 이루어진다.

-> 즉, enum에 switch문을 사용하면 자바 컴파일러가 모든 enum값을 switch에서 소모했는지 확인한다.

#### 인터페이스 분리 원칙
현재 Action 인터페이스 : 수행 코드와 코드를 실행시키는 조건이 분리되어 있지 않음
    
-> 실제 액션을 수행하지 않고도 각 액션과 관련된 조건을 기록하지 못 함


인터페이스 분리 원칙은 불필요한 결합을 만들기 때문에 어떤 클래스도 사용하지 않는 메서드에 의존성을 갖지 않아야 한다는 사상을 추구한다.

-> 즉, 인터페이스가 커지면 인터페이스 사용자는 결국 사용하지 않는 기능을 갖게 되며 이는 불필요한 결합도를 만든다.
(ISP는 설계가 아닌 사용자 인터페이스에 초점을 둔다.)

## 플루언트 API 설계
비즈니스 사용자의 도메인에 맞춰 단순하게 규칙(조건과 액션)을 추가하는 기능 제공
- 빌더 패턴
- 플루언트 API

### 플루언트 API
특정 문제를 더 직관적으로 해결할 수 있도록 특정 도메인에 맞춰진 API를 가리킨다.

플루언트 API의 메서드 체이닝을 이용하면 복잡한 연산도 지정할 수 있다.
- 자바 스트림 API : 문제를 실제로 해결하는 데 필요한 언어 사용하는 것처럼 데이터 처리 쿼리 지정
- 스프링 통합 : 엔터프라이즈 통합 패턴 도메인에 가까운 어휘로 엔터프라이즈 통합 패턴 지정하는 자바 API 제공
- JOOQ : 직관적 API로 다양한 데이터베이스와 상호작용하는 기능 제공 라이브러리

#### 도메인 모델링

```text
어떤 조건이 주어졌을 때(when), 이런 작업을 한다(then)
```
- 조건 : 어떤 팩트에 적용할 조건(참이나 거짓으로 평가된다.)
- 액션 : 실행할 연산이나 코드 집합
- 규칙 : 조건과 액션을 합친 것, 조건이 참일 때만 액션을 실행한다.

#### 빌더 패턴
빌터 패턴을 이용해 사용자가 각 객체를 인스턴스화한 다음, 한데로 모으아 객체와 필요한 조건, 액션을 만드는 과정을 개선 할 수 있다.

빌더 패턴은 단순하게 객체를 만드는 방법을 제공한다. 

생성자의 파라미터를 분해해서 각각의 파라미터를 받는 여러 메서드로 분리한다.
```java
//    public RuleBuilder(Condition condition, Action action){
//        this.condition = condition;
//        this.action = action;
//    }

    public RuleBuilder when(final Condition condition) {
        this.condition = condition;
        return this;
    }

    public RuleBuilder then(final Action action) {
        this.action = action;
        return this;
        //this를 반환하여 메서드를 연쇄적으로 연결한다.
    }
```
-> 덕분에 각 메서드는 도메인이 다루는 문제와 비슷한 이름을 가지게 되 객체를 설정하는 빌더 패턴 코드가 된다.

-> 도메인 용어를 내장 생성자로 활용할 수 있다.


플루언트 API 설계의 핵심이 메서드 체이닝입니다.

## 총정리
- 테스트 주도 개발 철학에 따르면 먼저 테스트를 구현하고 이를 가이드 삼아 코드를 구현한다.
- 모킹으로 유닛 테스트에서 어떤 동작이 실행되었는지 확인한다.
- 자바는 지역 변수 형식 추론과 switch문을 지원한다.
- 빌더 패턴은 복잡한 객체를 사용자 친화적인 API로 인스턴스화할 수 있도록 돕는다.
- 인터페이스 분리 원틱은 불필요한 메서드의 디펜던시를 감소시켜 높은 응집도를 촉진한다. 큰 인터페이스를 응집력 있는 작은 인터페이스로 분리해 사용자는 필요한 기능만 사용할 수 있다.

