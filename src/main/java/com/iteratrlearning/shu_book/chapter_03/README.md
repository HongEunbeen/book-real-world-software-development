# 확장된 입출금 내역 분석기 요구 사항
 -[ ] 특정 입출금 내역을 검색할 수 있는 기능. 예를 들어 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기.
 -[ ] 검색 결과의 요약 통계를 텍스트, HTML 등 다양한 형식으로 만들기.

# 개방/패쇄 원칙
확장에 대해 열려있고 수정에 대해 닫혀있는 원칙으로 애플리케이션의 요구 사항이 변경되었을 시에 모듈을 확장 즉, 모듈이 하는 일을 변경할 수는 있지
만 모듈의 소스코드나 바이너리 코드를 수정하지는 않아야 한다.

개방/패쇄 원칙을 적용시 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀 수 있다.

비즈니스 로직과 반복 로직 분리
- 비즈니스 로직 > `BankTransactionFilter` 인터페이스
    - 완료된 `BankTransaction` 객체를 인수로 받아 불리언 반환 `test` 메서드 포함
    - 함수형 인터페이스

중요한 리팩터링 ! 
새로운 인터페이스를 이용해 반복 로직과 비즈니스 로직의 결합을 제거하는 과정

-> 변경 없이도 확장성은 개방된다.
## 장점
- 기능을 확장하면 기존에 이미 구현하고 검증한 코드를 바꾸는 일 최소화
- 새로운 버그 발생할 만한 대상 줄임
- 예전 코드 바꾸지 않고 새로운 기능 추가 가능

## 람다 표현식
람다 표현식을 이용해 이름 없이 인터페이스 구현 객체를 코드 블록 형태로 전달 가능

## 정리
- 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
- 결합도가 낮아지므로 코드 유지보수성이 좋아진다.

# 인터페이스 문제
한 인터페이스에 모든 기능을 추가하는 갓 인터페이스를 만드는 일은 피해야 한다.

## 갓 인터페이스
- 자바의 인터페이스는 모든 구현이 지켜야 할 규직을 정의함 즉, 구현 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야 함.
- 인터페이스를 바꾸게 되면 이를 구현한 코드도 바뀐 내용을 지원하도록 갱신되어야 함.
- 더 많은 연산을 추가할수록 더 자주 코드가 바뀌며, 문제가 발생할 수 있는 범위도 넓어짐.

- 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제는 도메인 객체의 세부 내용이 바뀌면 인터페이스도 바뀌어야 하며 결과적으로 구현 코드도 바뀌어야 함.

-> 작은 인터페이스를 사용 시, 도메인 객체의 다양한 내부 연산으로의 디펜던시를 최소화할 수 있다.

🤔 그럼 작은 인터페이스가 좋은 것일까?

## 지나치게 세밀한 인터페이스
지나치게 인터페이스가 세밀해도 코드 유지보수에 방해가 된다.(ex : 안티응집도)
- 기능이 여러 인터페이스로 분산되므로 필요한 기능을 찾기가 어렵다.
    - 자주 사용하는 기능은 쉽게 찾을 수 있어야 유지보수성이 높아진다.
- 인터페이스가 너무 세밀하면 복잡도가 높아져 새로운 인터페이스가 속해서 프로젝트에 추가된다.

# 명시적 API vs 암묵적 API
- `findTransactions()`
    - 장점 : 모든 상황을 단순한 API로 처리 가능
    - 단점 : 처음 사용하기 어려움, 문서화를 잘해놓아야 함
- `findTransactionsGreaterThanEqual()`
    - 장점 : 자체적으로 어떤 동작 수행하는지 잘 설명, 쉬움
    - 단점 : 용도가 특정 상황에 국한 -> 각 상항에 맞는 메서드 많이 만들어야 함
    
-> 필요한 질문의 종류에 따라 어떤 방법을 사용할 지 달라진다.

## 도메인 클래스 vs 원싯값
원싯값으로는 다양한 결과를 반환할 수 없어 유연성이 떨어지기에 다양한 결과를 포함하도록 메서드 시그니처를 바꿔야 한다.

도메인 클래스를 사용했을 시 도메인의 다양한 개념간의 결합을 줄이고, 요구 사항이 바뀔 때 연쇄적으로 코드가 바뀌는 일도 최소화 할 수 있다.

# 다양한 형식으로 내보내기
## 도메인 객체 소개
- 숫자
- 컬렉션
- 특별한 도메인 객체
- 더 복잡한 도메인 객체

### 숫자
어떤 연산의 반환 결과가 필요할 때 사용하지만 요구 사항이 바뀔 때 유연하게 대처할 수 없고 새로운 버그가 발생할 가능성이 높다.
### 컬렉션
Iterable 반환시 상황에 맞춰서 처리하기에 유연성 높일 수 있지만 오직 컬렉션만 반환해야 한다는 제약 존재한다.
### 특별한 도메인 객체
요약 정보를 대표하는 새로운 개념 생성할 수 있다. 도메인 객체는 자신의 도메인과 관련된 클래스의 인스턴스로 도메인 객체를 이용하면 결합을 깰 수 있다.
새로운 요구 사항이 생겨 추가 정보를 내보내야 한다면 기존 코드를 바꿀 필요 없이 새로운 클래스의 일부로 구현 가능하다.
### 더 복잡한 도메인 객체
다양한 결과를 저장하는 필드를 포함하는 개념을 만들 수 있다. 요구사항, 복잡한 정보 여부에 따라 사용할 도메인 객체가 달라진다. 어떤 상황이든 객체를 생산하는 부분과 소비하는 부분이 서로 결합되지 않는다는 장점이 있다.

## 적절하게 인터페이스 정의/구현

인터페이스 구현의 나쁜 예
```java
public interface Exporter {
    void export(SummaryStatistics summaryStatistics);
}
```
- 인터페이스로부터 얻을 수 있는 정보가 없다.
- 어서션으로 결과를 테스트 하기 어렵다.

적절한 인터페이스 구현
```java
public interface Exporter {
    String export(SummaryStatistics summaryStatistics);
}
```
- 텍스트 문자열은 어셔선으로 직접 비교 가능해 쉽게 테스트 가능하다.

# 예외 처리
- 데이터를 적절하게 파싱하지 못 한다면?
- 입출금 내역을 포함하는 CSV 파일을 읽을 수 없다면?
- 응용프로그램을 실행하는 하드웨어에 램이나 저장 공간이 부족하다면?

이러한 문제가 발생하면 스택 트레이스(문제가 어디서 발생했는지를 보여줌)와 함께 이상한 오류 메시지가 나타남

## 예외 사용해야 하는 이유
- `if`문을 사용해서 오류 코드 반환시의 문제점
    - 전역으로 공유된 가변 상태에 의존해 최근에 발생한 오류 검색
    - 코드 부분이 따로 분리되어 이해하기 어려워짐
    - 코드 유지보수하기 어려움
    - 실제 값인지 아니면 오류를 가리키는 값인지 구분하기 어려움
    - 제어 흐름이 비즈니스 로직과 섞이면서 코드 유지보수, 테스트 어려움
    
-> 이러한 문제를 해결 위해 자바는 예외를 일급 언어 기능으로 추가
- 문서화 : 메서드 시그니처 자체에 예외 지원
- 형식 안전성 : 예외 흐름을 처리하고 있는지를 형식 시스템이 파악
- 관심사 분리 : 비즈니스 로직과 예외 회복이 각각 `try/catch` 블록으로 구분

예외 기능으로 복잡성 증가 단점 존재 BUT 자바는 두 가지 예외 제공
- 확인된 예외 : 회복해야 하는 대상의 예외
    - 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 함
    - 선언하지 않을 시 해당 예외를 `try/catch`로 처리
    - `Exception`
- 미확인 예외 : 프로그램을 실행하면서 언제든 발생할 수 있는 종류의 예외
    - 메서드 시그니처에 명시적으로 오류를 선언하지 않으면 호출자도 이를 꼭 처리할 필요 없음
    - `Error` `RuntimeException`
    
## 예외의 패턴과 안티 패턴(예외 사용 상황)
### 미확인 예외와 확인된 예외에서 선택하기
선택하는 방법은 예외가 발생했을 때 프로그램이 회복되도록 강제 여부를 생각하기!

### 문법 문제
- 확인된 예외
- 미확인 예외
    - 일시적으로 발생하는 오류
    - 비즈니스 로직 검증시 발생 문제
    - 예외 발생시 응용 프로그램 어떻게 회복할지 애매한 상황
        - 시스템 오류가 발생했을 때에는 사용자가 할 수 있는 일이 없다..

즉, 대다수의 예외 = 미확인 예외로 지정, 꼭 필요한 상황에서만 확인된 예외로 지정해 불필요한 코드(try/catch문) 줄여야 한다.

### 데이터 검증 문제
흔히 발생하는 안티 패턴
- 과도하게 세밀함
- 과도하게 덤덤함

과도 세밀함과 과도한 덤덤함에서 발생한 문제 유지보수 해결책
- 노티피케이션

검증 로직은 전용 Validator 클래스를 만드는걸 권장
- 검증 로직을 재사용해 코드를 중복하지 않는다.
- 시스템의 다른 부분도 같은 방법으로 검증할 수 있다.
- 로직을 독립적으로 유닛 테스트할 수 있다.
- 이 기법은 프로그램 유지보수와 이해하기 쉬운 SRP를 따른다.


#### 과도하게 세밀함
발생할 수 있는 모든 경계 상황을 고려하고, 각각의 경계 상황을 별도의 확인된 예외로 변환하는 상황

- 장점 : 각각의 예외에 적합하고 정확한 회복 기법을 구현할 수 있음
- 문제점 : 많은 설정 작업 필요, 여러 예외 선언 필요, 사용자 모든 예외 처리로 생산성 현저하게 떨어짐

즉, 사용자가 API 사용을 쉽게 할 수 없고 여로 오류 발생시 모든 오류 목록 제공 불가!

#### 과도하게 덤덤함
모든 예외를 `IllegalArgumentException` 등의 미확인 예외로 지정하는 극단적인 상황

- 문제점 : 전부 동일한 예외로 지정 시 구체적인 회복 로직 만들 수 없음

즉, 여러 오류가 발생시 모든 오류 목록 제공 불가

#### 노티피케이션 패턴
도메인 클래스로 오류를 수집해 너무 많은 미확인 예외를 사용하는 상황에 적합한 해결책 제공

- 과도한 세밀함, 과도한 덤덤함 : 여러 오류 수집 불가
- 노티피케이션 : 한 번에 여러 오류 수집 가능한 검증자 생성 -> 오류를 던지지 않고 객체에 메시지 추가!

##예외 사용 가이드 라인
- 예외를 무시하지 않음
- 일반적인 예외는 잡지 않음
- 예외 문서화
- 특정 구현에 종속된 예외를 주의할 것
- 예외 vs 제어 흐름
#### 예외를 무시하지 않음
예외를 처리할 방법이 명확하지 않으면 미확인 예외 던지기! 이렇게 되면
확인된 예외를 정말 처리해야 할 때 런타임에서 어떤 문제 발생 확인한 다음 필요한 작업 다시 시작 가능
#### 일반적인 예외는 잡지 않음
가능한 구체적으로 예외 잡으면 가독성 높아지고 세밀하게 예외 처리 가능. 일반적인 `Exception`은 `RuntimeExcpetion`도 포함!
#### 예외 문서화
API 수준에서 미확인 예외를 포함한 예외를 문서화해 API 사용자에게 문제 해결 실마리 제공(미확인 예외 보고서는 해결해야 할 문제의 원인 포함)
#### 특정 구현에 종속된 예외를 주의할 것
특정 구현에 종속된 예외를 던지면 API의 캡슐화가 깨짐 (ex. `OracleException`을 던지면 오라클에 종속된 코드가 된다.)
#### 예외 vs 제어 흐름
자바에서 예외를 남용하는 건 나쁜 사례로 예외로 흐름을 제어하지 않음
```java
try{
    while(true){
      System.out.println(source.read());
    }    
}catch(NoDataException e){
}
```
 - 예외를 처리하느라 불필요한 문법 추가되어 코드 가독성 떨어짐
 - 코드의 의도도 이해하기 어려워짐
 - **예외가 발생했을 때 스택 트레이스 생성, 보존과 관련된 부담이 생김**

**예외는 오류와 예외적인 시나리오를 처리하는 기능!**
예외를 정말 던져야 하는 상황이 아니면 예외를 만들지 않아야 한다.
##예외 대안 기능
- `null` 사용
- `null` 객체 패턴
- `Optional<T>`
- `Try<T>`
####`null` 사용
예외를 던지지 않고 `null`을 반환하는 패턴은 절대 사용하지 않아야 한다. null은 호출자에게 아무런 정보도 제공하지 않아 API의 결과가 `Null` 인지 항상 확인해야 하고 `NullPointerException`이 발생할 수 있다.
####`null` 객체 패턴
Null 객체 패턴 : 객체가 존재하지 않을 때 Null 레퍼런스를 반환하는 대신 필요한 인터페이스에 구현하는 객체를 반환하는 기법
- 장점 : 의도하지 않은 `Exception`이나 긴 `null` 확인 코드 피할 수 있음(빈 객체는 아무것도 수행하지 않으므로 동작 예측 쉬움!)
- 단점 : 데이터에 문제가 있어도 빈 객체를 이용해 실제 문제를 무시 가능해 문제 해결 더 복잡함
####`Optional<T>`
값이 없는 상태를 표현하는 내장 데이터 형식 `java.util.Optional<T>`
- 장점 : 값이 없는 상태를 명시적으로 처리하는 다양한 메서드 집합 제공으로 버그의 범위 줄임
다양한 Optional 객체 조합가능으로 형식 조합해 사용할 수 있다.
####`Try<T>`
성공하거나 실패할 수 있는 연산을 가리키는 데이터 형식

`Optional<T>`와 비슷하지만 값이 아니라 연산에 적용한다는 점 다르다.
- 장점 : 데이터 형식도 코드 조합성의 장점을 제공해 코드에서 발생하는 오류 범위 줄여줌
- 단점 : JDK 미 지원으로 외부 라이브러리 사용해야 함

