# 확장된 입출금 내역 분석기 요구 사항
 -[ ] 특정 입출금 내역을 검색할 수 있는 기능. 예를 들어 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기.
 -[ ] 검색 결과의 요약 통계를 텍스트, HTML 등 다양한 형식으로 만들기.

# 개방/패쇄 원칙
확장에 대해 열려있고 수정에 대해 닫혀있는 원칙으로 애플리케이션의 요구 사항이 변경되었을 시에 모듈을 확장 즉, 모듈이 하는 일을 변경할 수는 있지
만 모듈의 소스코드나 바이너리 코드를 수정하지는 않아야 한다.

개방/패쇄 원칙을 적용시 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀 수 있다.

비즈니스 로직과 반복 로직 분리
- 비즈니스 로직 > `BankTransactionFilter` 인터페이스
    - 완료된 `BankTransaction` 객체를 인수로 받아 불리언 반환 `test` 메서드 포함
    - 함수형 인터페이스

중요한 리팩터링 ! 
새로운 인터페이스를 이용해 반복 로직과 비즈니스 로직의 결합을 제거하는 과정

-> 변경 없이도 확장성은 개방된다.
## 장점
- 기능을 확장하면 기존에 이미 구현하고 검증한 코드를 바꾸는 일 최소화
- 새로운 버그 발생할 만한 대상 줄임
- 예전 코드 바꾸지 않고 새로운 기능 추가 가능

## 람다 표현식
람다 표현식을 이용해 이름 없이 인터페이스 구현 객체를 코드 블록 형태로 전달 가능

## 정리
- 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
- 결합도가 낮아지므로 코드 유지보수성이 좋아진다.

# 인터페이스 문제
한 인터페이스에 모든 기능을 추가하는 갓 인터페이스를 만드는 일은 피해야 한다.

## 갓 인터페이스
- 자바의 인터페이스는 모든 구현이 지켜야 할 규직을 정의함 즉, 구현 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야 함.
- 인터페이스를 바꾸게 되면 이를 구현한 코드도 바뀐 내용을 지원하도록 갱신되어야 함.
- 더 많은 연산을 추가할수록 더 자주 코드가 바뀌며, 문제가 발생할 수 있는 범위도 넓어짐.

- 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제는 도메인 객체의 세부 내용이 바뀌면 인터페이스도 바뀌어야 하며 결과적으로 구현 코드도 바뀌어야 함.

-> 작은 인터페이스를 사용 시, 도메인 객체의 다양한 내부 연산으로의 디펜던시를 최소화할 수 있다.

🤔 그럼 작은 인터페이스가 좋은 것일까?

## 지나치게 세밀한 인터페이스
지나치게 인터페이스가 세밀해도 코드 유지보수에 방해가 된다.(ex : 안티응집도)
- 기능이 여러 인터페이스로 분산되므로 필요한 기능을 찾기가 어렵다.
    - 자주 사용하는 기능은 쉽게 찾을 수 있어야 유지보수성이 높아진다.
- 인터페이스가 너무 세밀하면 복잡도가 높아져 새로운 인터페이스가 속해서 프로젝트에 추가된다.

# 명시적 API vs 암묵적 API
- `findTransactions()`
    - 장점 : 모든 상황을 단순한 API로 처리 가능
    - 단점 : 처음 사용하기 어려움, 문서화를 잘해놓아야 함
- `findTransactionsGreaterThanEqual()`
    - 장점 : 자체적으로 어떤 동작 수행하는지 잘 설명, 쉬움
    - 단점 : 용도가 특정 상황에 국한 -> 각 상항에 맞는 메서드 많이 만들어야 함
    
-> 필요한 질문의 종류에 따라 어떤 방법을 사용할 지 달라진다.

## 도메인 클래스 vs 원싯값
원싯값으로는 다양한 결과를 반환할 수 없어 유연성이 떨어지기에 다양한 결과를 포함하도록 메서드 시그니처를 바꿔야 한다.

도메인 클래스를 사용했을 시 도메인의 다양한 개념간의 결합을 줄이고, 요구 사항이 바뀔 때 연쇄적으로 코드가 바뀌는 일도 최소화 할 수 있다.

# 다양한 형식으로 내보내기
## 도메인 객체 소개
- 숫자
- 컬렉션
- 특별한 도메인 객체
- 더 복잡한 도메인 객체

### 숫자
어떤 연산의 반환 결과가 필요할 때 사용하지만 요구 사항이 바뀔 때 유연하게 대처할 수 없고 새로운 버그가 발생할 가능성이 높다.
### 컬렉션
Iterable 반환시 상황에 맞춰서 처리하기에 유연성 높일 수 있지만 오직 컬렉션만 반환해야 한다는 제약 존재한다.
### 특별한 도메인 객체
요약 정보를 대표하는 새로운 개념 생성할 수 있다. 도메인 객체는 자신의 도메인과 관련된 클래스의 인스턴스로 도메인 객체를 이용하면 결합을 깰 수 있다.
새로운 요구 사항이 생겨 추가 정보를 내보내야 한다면 기존 코드를 바꿀 필요 없이 새로운 클래스의 일부로 구현 가능하다.
### 더 복잡한 도메인 객체
다양한 결과를 저장하는 필드를 포함하는 개념을 만들 수 있다. 요구사항, 복잡한 정보 여부에 따라 사용할 도메인 객체가 달라진다. 어떤 상황이든 객체를 생산하는 부분과 소비하는 부분이 서로 결합되지 않는다는 장점이 있다.

## 적절하게 인터페이스 정의/구현

인터페이스 구현의 나쁜 예
```java
public interface Exporter {
    void export(SummaryStatistics summaryStatistics);
}
```
- 인터페이스로부터 얻을 수 있는 정보가 없다.
- 어서션으로 결과를 테스트 하기 어렵다.

적절한 인터페이스 구현
```java
public interface Exporter {
    String export(SummaryStatistics summaryStatistics);
}
```
- 텍스트 문자열은 어셔선으로 직접 비교 가능해 쉽게 테스트 가능하다.

# 예외 처리
- 데이터를 적절하게 파싱하지 못 한다면?
- 입출금 내역을 포함하는 CSV 파일을 읽을 수 없다면?
- 응용프로그램을 실행하는 하드웨어에 램이나 저장 공간이 부족하다면?

이러한 문제가 발생하면 스택 트레이스(문제가 어디서 발생했는지를 보여줌)와 함께 이상한 오류 메시지가 나타남

## 예외 사용해야 하는 이유
- `if`문을 사용해서 오류 코드 반환시의 문제점
    - 전역으로 공유된 가변 상태에 의존해 최근에 발생한 오류 검색
    - 코드 부분이 따로 분리되어 이해하기 어려워짐
    - 코드 유지보수하기 어려움
    - 실제 값인지 아니면 오류를 가리키는 값인지 구분하기 어려움
    - 제어 흐름이 비즈니스 로직과 섞이면서 코드 유지보수, 테스트 어려움
    
-> 이러한 문제를 해결 위해 자바는 예외를 일급 언어 기능으로 추가
- 문서화 : 메서드 시그니처 자체에 예외 지원
- 형식 안전성 : 예외 흐름을 처리하고 있는지를 형식 시스템이 파악
- 관심사 분리 : 비즈니스 로직과 예외 회복이 각각 `try/catch` 블록으로 구분

예외 기능으로 복잡성 증가 단점 존재 BUT 자바는 두 가지 예외 제공
- 확인된 예외 : 회복해야 하는 대상의 예외
    - 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 함
    - 선언하지 않을 시 해당 예외를 `try/catch`로 처리
    - `Exception`
- 미확인 예외 : 프로그램을 실행하면서 언제든 발생할 수 있는 종류의 예외
    - 메서드 시그니처에 명시적으로 오류를 선언하지 않으면 호출자도 이를 꼭 처리할 필요 없음
    - `Error` `RuntimeException`
    
## 예외의 패턴과 안티 패턴(예외 사용 상황)
### 미확인 예외와 확인된 예외에서 선택하기
선택하는 방법은 예외가 발생했을 때 프로그램이 회복되도록 강제 여부를 생각하기!

### 문법 문제
- 확인된 예외
- 미확인 예외
    - 일시적으로 발생하는 오류
    - 비즈니스 로직 검증시 발생 문제
    - 예외 발생시 응용 프로그램 어떻게 회복할지 애매한 상황
        - 시스템 오류가 발생했을 때에는 사용자가 할 수 있는 일이 없다..

즉, 대다수의 예외 = 미확인 예외로 지정, 꼭 필요한 상황에서만 확인된 예외로 지정해 불필요한 코드(try/catch문) 줄여야 한다.

### 데이터 검증 문제
흔히 발생하는 안티 패턴
- 과도하게 세밀함
- 과도하게 덤덤함

과도 세밀함과 과도한 덤덤함에서 발생한 문제 유지보수 해결책
- 노티피케이션

검증 로직은 전용 Validator 클래스를 만드는걸 권장
- 검증 로직을 재사용해 코드를 중복하지 않는다.
- 시스템의 다른 부분도 같은 방법으로 검증할 수 있다.
- 로직을 독립적으로 유닛 테스트할 수 있다.
- 이 기법은 프로그램 유지보수와 이해하기 쉬운 SRP를 따른다.


#### 과도하게 세밀함
발생할 수 있는 모든 경계 상황을 고려하고, 각각의 경계 상황을 별도의 확인된 예외로 변환하는 상황

- 장점 : 각각의 예외에 적합하고 정확한 회복 기법을 구현할 수 있음
- 문제점 : 많은 설정 작업 필요, 여러 예외 선언 필요, 사용자 모든 예외 처리로 생산성 현저하게 떨어짐

즉, 사용자가 API 사용을 쉽게 할 수 없고 여로 오류 발생시 모든 오류 목록 제공 불가!

#### 과도하게 덤덤함
모든 예외를 `IllegalArgumentException` 등의 미확인 예외로 지정하는 극단적인 상황

- 문제점 : 전부 동일한 예외로 지정 시 구체적인 회복 로직 만들 수 없음

즉, 여러 오류가 발생시 모든 오류 목록 제공 불가

#### 노티피케이션 패턴
도메인 클래스로 오류를 수집해 너무 많은 미확인 예외를 사용하는 상황에 적합한 해결책 제공

- 과도한 세밀함, 과도한 덤덤함 : 여러 오류 수집 불가
- 노티피케이션 : 한 번에 여러 오류 수집 가능한 검증자 생성 -> 오류를 던지지 않고 객체에 메시지 추가!

##예외 사용 가이드 라인
- 예외를 무시하지 않음
- 일반적인 예외는 잡지 않음
- 예외 문서화
- 특정 구현에 종속된 예외를 주의할 것
- 예외 vs 제어 흐름
#### 예외를 무시하지 않음
예외를 처리할 방법이 명확하지 않으면 미확인 예외 던지기! 이렇게 되면
확인된 예외를 정말 처리해야 할 때 런타임에서 어떤 문제 발생 확인한 다음 필요한 작업 다시 시작 가능
#### 일반적인 예외는 잡지 않음
가능한 구체적으로 예외 잡으면 가독성 높아지고 세밀하게 예외 처리 가능. 일반적인 `Exception`은 `RuntimeExcpetion`도 포함!
#### 예외 문서화
API 수준에서 미확인 예외를 포함한 예외를 문서화해 API 사용자에게 문제 해결 실마리 제공(미확인 예외 보고서는 해결해야 할 문제의 원인 포함)
#### 특정 구현에 종속된 예외를 주의할 것
특정 구현에 종속된 예외를 던지면 API의 캡슐화가 깨짐 (ex. `OracleException`을 던지면 오라클에 종속된 코드가 된다.)
#### 예외 vs 제어 흐름
자바에서 예외를 남용하는 건 나쁜 사례로 예외로 흐름을 제어하지 않음
```java
try{
    while(true){
      System.out.println(source.read());
    }    
}catch(NoDataException e){
}
```
 - 예외를 처리하느라 불필요한 문법 추가되어 코드 가독성 떨어짐
 - 코드의 의도도 이해하기 어려워짐
 - **예외가 발생했을 때 스택 트레이스 생성, 보존과 관련된 부담이 생김**

**예외는 오류와 예외적인 시나리오를 처리하는 기능!**
예외를 정말 던져야 하는 상황이 아니면 예외를 만들지 않아야 한다.
##예외 대안 기능
- `null` 사용
- `null` 객체 패턴
- `Optional<T>`
- `Try<T>`
####`null` 사용
예외를 던지지 않고 `null`을 반환하는 패턴은 절대 사용하지 않아야 한다. null은 호출자에게 아무런 정보도 제공하지 않아 API의 결과가 `Null` 인지 항상 확인해야 하고 `NullPointerException`이 발생할 수 있다.
####`null` 객체 패턴
Null 객체 패턴 : 객체가 존재하지 않을 때 Null 레퍼런스를 반환하는 대신 필요한 인터페이스에 구현하는 객체를 반환하는 기법
- 장점 : 의도하지 않은 `Exception`이나 긴 `null` 확인 코드 피할 수 있음(빈 객체는 아무것도 수행하지 않으므로 동작 예측 쉬움!)
- 단점 : 데이터에 문제가 있어도 빈 객체를 이용해 실제 문제를 무시 가능해 문제 해결 더 복잡함
####`Optional<T>`
값이 없는 상태를 표현하는 내장 데이터 형식 `java.util.Optional<T>`
- 장점 : 값이 없는 상태를 명시적으로 처리하는 다양한 메서드 집합 제공으로 버그의 범위 줄임
다양한 Optional 객체 조합가능으로 형식 조합해 사용할 수 있다.
####`Try<T>`
성공하거나 실패할 수 있는 연산을 가리키는 데이터 형식

`Optional<T>`와 비슷하지만 값이 아니라 연산에 적용한다는 점 다르다.
- 장점 : 데이터 형식도 코드 조합성의 장점을 제공해 코드에서 발생하는 오류 범위 줄여줌
- 단점 : JDK 미 지원으로 외부 라이브러리 사용해야 함

# 빌드 도구 사용

## 빌드 도구 사용 이유
응용프로그램 실행 위해 프로젝트 코드를 구현 후 자바 컴파일러(javac) 컴파일
- 여러 파일, 여러 패키지 컴파일 시 어떤 명령?
- 다른 라이브러리 사용시 디펜던시 어떻게 관리?
- 프로젝트 WAR, JAR 같은 특정한 형식으로 어떻게 패키징?

🤔 스크립트 만들어 모든 명령어 자동화 하면 되지 않을까?
- 모든 동료 개발자 스크립트 어떻게 구성되어 있는지 유지보수 위해 이해 필요
- 소프트웨어 개발 생명 주기 고려
- 코드 컴파일 후 테스트나 배포는?

이런 문제 해결 위해 ! 빌드 도구 사용!

###빌드 도구 장점
- 프로젝트에 적용되는 **공통적인 구조 제공**으로 프로젝트 편안하게 받아 들임
- 응용프로그램 빌드하고 실행하는 반복적, **표준적 작업 설정**
- 저수준 설정과 초기화 들이는 시간 절약으로 **개발에만 집중 가능**
- 잘못된 설정, 일부 빌드 과정 생략으로 **오류의 범위 줄임**
- 공통 빌드 작업 재사용으로 구현할 필요가 없으므로 **시간 절약**

##유명한 빌드 도구
- 메이븐
- 그레이들
### 메이븐
 2004년 처음 출시되었고 XML 기반으로 빌드 과정을 정의한다. 메이븡르 이용해 소프트웨어의 디펜던시와 빌드 과정을 작성!
#### 프로젝트 구조
유지보수에 도움되는 구조를 처음부터 제공
- 두 메인 폴더 제공
  - `src/main/java` : 프로젝트에 필요한 모든 자바 클래스 개발해 저장 폴더
  - `src/test/java` : 프로젝트의 테스트 코드 개발해 저장 폴더
- 유용하게 사용할 만한 폴더
  - `src/main/resources` : 응용프로그램에서 사용하는 추가 자원 포함 폴더
  - `src/test/resources` : 테스트에서 사용할 추가 자원 포함 폴더

`pom.xml` 파일을 만들어 응용 프로그램 빌드에 필요한 과정 다양한 XML 정의로 지정해 빌드 프로세스 정의
#### 빌드 파일 예제(`pom.xml`)
- `project`
  - pom.xml 파일의 최상위 수준 요소
- `groupId` 
  - 프로젝트를 만드는 조직의 고유 식별자 지정
- `artifactId`
  - 빌드 과정에서 생성된 부산물의 고유한 기본 이름 지정
- `packaging`
  - 부산물에 사용할 패키지 형식(JAR, WAR, EAR 등) 지정
  - default : JAR
- `version`
  - 프로젝트에서 생성하는 부산물 버전 지정
- `build`
  - 플러그인, 자원 등 빌드 과정을 가이드하는 다양한 설정 지정
- `dependencies`
  - 프로젝트의 디펜던시 목록 지정
  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.iteratrlearning</groupId>
    <artifactId>shu_book</artifactId>
    <version>1.0-SNAPSHOT</version>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.7.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <properties>
        <jackson.version>2.10.1</jackson.version>
        <jetty.version>9.4.24.v20191120</jetty.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <repositories>
        <repository>
            <id>clojars.org</id>
            <url>http://clojars.org/repo</url>
        </repository>
    </repositories>

</project>

```

#### 메이븐 명령어
pom.xml 설정 후 메이븐으로 프로젝트 만들고 패키징 명령어
- `mvn clean`
  - 빌드 전 기존 빌드에서 생성된 부산물 정리
- `mvn compile`
  - 프로젝트의 소스코드를 컴파일
  - 기본적으로 생성된 target 폴더에 결과 저장
- `mvn test`
  - 컴파일된 소스코드 테스트
- `mvn package`
  - 컴파일된 코드를 JAR과 같은 적절한 형식으로 패키징

### 그레이들
**메이븐의 단점**
- XML을 이용하기에 작업하기 귀찮고, 가독성 떨어짐
- XML은 장황한 언어로 유지보수 부담이 존재

**그레이들 장점**
- 그루비, 코틀린 프로그래밍 언어 등을 이용해 친군한 도메인 특화 언어(DSL) 적용
  - 더 자연스럽게 빌드 지정, 쉽게 커스터마이즈 가능, 쉽게 이해 가능
- 캐시, 점진적 컴파일 등 빌드 시간 단축 기능 지원

#### 빌드 파일 예제
그레이들은 메이븐과 프로젝트 구조 비슷!

- `build.gradle`(`pom.xml`) 파일 선언
- `setting.gradle` 파일 선언
  - 여러 프로젝트 빌드와 설정 변수 포함
  
```
plugins {
    id 'application' 
}

repositories {
    mavenCentral() 
}

dependencies {
    testImplementation 'junit:junit:4.13.1' 

    implementation 'com.google.guava:guava:30.0-jre' 
}

application {
    mainClass = 'demo.App' 
}
```
메이븐 빌드 파일보다 훨씬 간결!!!
#### 그레이들 명령어
그레이들의 각 명령은 태스크로 구성(test,build, clean 등 내장 태스크 실행 or 직접 태스크 정의해 실행!)
- `gradle clean`
  - 이전 빌드에서 생성된 파일 정리
- `gradle build`
  - 응용프로그램 패키징
  - 그레이들이 만든 build 폴더에 JAR 생성
- `gradle test`
  - 테스트 실행
- `gradle run`
  - `application` 플러그인의 `mainClassName`으로 지정된 메인 클래스 실행
# 정리
- 개방/패쇄 원칙 이용하면 코드를 바꾸지 않아도 메서드, 클래스의 동작 변경 가능
- 개방/패쇄 원칙 이용하면 코드가 망가질 가능성이 줄어들며, 기존 코드의 재사용성 높이고, 결합도 높아지므로 코드 유지보수성 개선
- 많은 매서드 포함하는 갓 인터페이스는 복잡도와 결합도 높인다.
- 너무 세밀한 메서드를 포함하는 인터페이스는 응집도를 낮춘다.
- API의 가독성을 높이고 쉽게 이해할 수 있도록 메서드 이름을 서술적으로 만들어야 한다.
- 연산 결과로 `void`를 반환하면 동작을 테스트하기가 어렵다.
- 자바의 예외는 문서화, 형식 안정성, 관심사 분리를 촉진한다.
- 확인된 예외는 불필요한 코드를 추가해야 하므로 되도록 사용하지 않는다.
- 너무 자세하게 예외를 적용하면 소프트웨어 개발의 생산성이 떨어진다.
- 노티피케이션 패턴을 이용하면 도메인 클래스로 오류를 수집할 수 있다.
- 예외를 무시하거나 일반적인 `Exception`을 잡으면 근본적인 문제를 파악하기가 어렵다.
- 빌드 도구를 사용하면 응용프로그램 빌드, 테스트, 배포 등 소프트웨어 개발 생명 주기 작업을 자동화할 수 있다.
- 요즘 자바 커뮤니티에서는 빌드 도구로 메이븐과 그레이들을 주로 사용한다.