# 입출금 내역 분석기 요구 사항

- [ ] 은행 입출금 내역의 총 수입과 총 지출은 각각 얼마인가? 결과가 양수인가 음수인가?
- [ ] 특정 달엔 몇 건의 입출금 내역이 발생했는가?
- [ ] 지출이 가장 높은 상위 10건은 무엇인가?
- [ ] 돈을 가장 많이 소비하는 항목은 무엇인가?

# final 변수
final 변수 사용의 장점
- 어떤 객체의 상태가 바뀔 수 있고, 어떤 객체의 상태가 바뀔 수 없는지 명확하게 구분할 수 있다.

final 키워드 적용해도 객체가 바뀌지 못하도록 강요 불가

- final 필드로 가리키는 객체라도 가변상태를 포함하기 때문

추상 메서드에서는 final 키워드의 의미가 무력화 된다.

# 코드 유지보수성과 안티 패턴

- 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야 한다.
- 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야 한다.
- 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야 한다.
- 캡슐화가 잘 되어 있어야 한다. 즉, 코드 사용자에게는 세부 구현 내용잉 감춰져 있으므로 사용자가 쉽게 코드를 이해하고, 기능을 바꿀 수 있어야 한다.

## 코드 복사, 붙여넣기 안티패턴의 문제점
- 한 개의 거대한 갓 클래스 때문에 코드를 이해하기 어렵다.
- 코드 중복 때문에 불안정하고 변화에 쉽게 망가진다.

### 갓 클래스 안티패턴
- 한 클래스로 모든 것을 해결하는 패턴
- 한 개의 파일에 모든 코드를 구현하는 방식으로 목적 무엇인지 이해 어려움

### 코드 중복 안티패턴 
- 코드가 중복되어있어 기존의 기능 변경 어려움
    - 중복 배체 원칙으로 반복을 제거하면 로직을 바꿔도 여러 곳의 코드 바궈야 할 필요성 없음

결론적으로 코드 간결 유지하는것도 중요하지만, KISS 원칙 남용하지 않는것도 중요
- 한 문제를 작은 개별 문제로 분리해 더 쉽게 관리할 수 있는지 파악하기

# 단일 책임 원칙(SRP)
쉽게 관리하고 유지보수하는 코드를 구현하는데 도움을 주는 포괄적인 소프트웨어 개발 지침
- 한 클래스는 한 기능만 책임진다.
- 클래스가 바뀌어야 하는 이유는 오직 하나여야 한다.
    - 코드가 바뀌는 이유가 한 가지가 아니라면, 여러 장소에서 변경이 발생해 유지보수 어려워짐

### SRP 적용 대상
- 클래스
- 메서드
SRP는 한 가지 특정 동작, 개념, 카테고리와 관련된다!
  
### SRP 적용 방법
Main 클래스의 여러 책임을 개별로 분리
1. 입력 읽기
2. 주어진 형식의 입력 파싱 
3. 결과 처리
4. 결과 요약 리포트

- BankStatementCSVParser
  - 파싱 기능을 위임 받았고, 이 기능을 독립적으로 구현
  - 새로운 요구 사항 발생 시, 캡슐화된 기능을 재사용해 구현 가능
- BankTransaction
  - 다른 코드가 특정 데이터 형식에 의존하지 않는다.
- BankStatementAnalyzer(Main)
  - 파싱 알로기즘 동작 방식 변경 발생 시 한 곳의 코드만 변경 가능

# 놀람 최소화 원칙(principle of least surprise)
누군가가 놀라지 않도록 일관성을 유지하는 범위에서 코드를 구현할 것을 강조하는 원칙으로 원칙

- 메서드가 수행하는 일을 바로 이해할 수 있도록 자체 문서화를 제공하는 메서드명을 사용한다.
- 코드의 다른 부분이 파라미터의 상태에 의존할 수 있으므로 파라미터의 상태를 바꾸지 않는다.

하지만 주관적인 개념으로 확신이 서지 않는다면 동료와 함께 의논 필요

# 응집도
- KISS
- DRY
- SRP

코드 품질과 관련한 특성으로 서로 어떻게 관련되어 있는지를 가르킨다. 응집도는 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지 측정한다.
즉, 어떤 것이 여기저기에 모두 속해 있는지를 말한다.
- 소프트웨어의 복잡성을 유추하는데 도움
- 코드 유지보수성을 결정하는 중요한 개념
- 누구나 쉽게 코드를 찾고, 이해하고, 사용할 수 있도록 만든다.

## 응집도 개념 적용
- 클래스(클래스 수준 응집도)
- 메서드(메서드 수준 응집도)

`BankStatementAnalyzer`

다양한 부분을 연결하는 클래스이지만 계산 로직 정적 메서드로 선언되어 있음
- 계산 관련 작업은 파싱이나 결과 전송과 직접적인 관련 없음 -> 응집도 떨어짐

