# 문서 관리 시스템 요구 사항

문서 관리 시스템은 기존 환자 정보 파일을 일어 색인을 추가하고 검색할 수 있는 형태의 정보로 변환

- 리포트 : 환자의 수술과 관련된 상담 내용을 기록한 본문이다.
- 우편물 : 특정 주소로 발송되는 텍스트 문서다.
- 이미지 : 치아와 잇몸 엑스레이 사진을 저장한다. 용량이 크다.

### 설계 작업
다양한 설계와 모델힝 방식 중 테스트 주도 개발 사용

#### 임포터
다양한 종류의 문서를 임포트하는 것이 문서 관리 시스템의 핵심

다양한 문서를 임포트하는 클래스로 분리해 각각의 임포트 동작 따로 처리

-> 찾기 쉽고, 이해하기 쉬운 코드를 만들 수 있다.
```Java
public interface Importer {
    Document importFile(File file) throws IOException;
}
```

🤔 문서 관리 시스템의 공개 API에서는 왜 File을 사용하지 않을까?
-> 공개 API가 다른 종류의 사용자 인터페이스로 감싸진 상태이므로 어떤 파일을 지원하는지 알 수 없기에 String 형식으로 간단하게 일을 처리합니다.

### Document 클래스
- 각 문서는 검색할 수 있는 다양한 속성을 포함한다.
- 문서의 종류에 따라 포함하는 속성이 달라진다.

구현할 수 있는 방법
- Map<String, String> 으로 속성 이름을 값과 매핑하는 방법

##### 도메인 클래스
도메인 클래스를 이용하면 개념에 이름을 붙이고 수행할 수 있는
동작과 값을 제한하므로 발견성을 개선하고 버그 발생 범위를 줄일 수 있다.

#### Document 속성 및 계층

Document 클래스는 속성에 String을 사용했다.
-> 속성을 텍스트로 저장하면 텍스트로 속성을 검색할 수 있다.

만약, 속성값을 복잡하게 사용할 때는 다양한 속성 형식으로 파싱해 String 보다 강한 형식을 가진 속성이 훨씬 도움이 된다.

Importer의 구성 계층을 그대로 Document 클래스 계층에 사용할 수 있다.

문서의 각 서브 클래스가 전용 필드를 갖지 않도록 모든 알려진 속성을 범용으로 설계했다.

#### 임포터 구현과 등록

#### 문서 검색 기능
Document의 다양한 속성으로 정보를 검색할 수 있어야 한다.

속성값에서 일부 문자열을 검색할 수 있다면 요구 사항을 구현할 수 있다.
-> 환자 이름은 조 이고 본문에 Diet Coke 포함하는 문서 검색

속성명과 일부 문자열 쌍을 콤마로 분리한 형태의 단순 쿼리 언어를 만들어 처리

`patient:Joe, body:Diet Coke`

구현 방식은 search() 메서드로 전달한 쿼리 String은 Query 객체로 파싱되며 이를 각각의 Document
와 대조한다.

### 리스코드 치환 원칙(LSP)
클래스 상속과 인터페이스 구현을 올바르게 사용하도록 도와준다.
- 형식 : 클래스나 인터페이스
- 하위 형식 : 두형식이 부모와 자식 관계를 이루었음을 의미
  
    -> 클래스 상속이나 인터페이스 구현이 이에 해당된다.
  
```text
q(x)는 T형식의 x 객체를 증명할 수 있는 공식이다. 그러면 S형식의 객체 y가 있고 S가 T의 하위 형식이라면 q(y)는 참이다.
```
LSP를 네개의 부분으로 쪼갠다면
- 하위형식에서 선행조건을 더할 수 없음
- 하위형식에서 후행조건을 약화시킬 수 없음
- 슈퍼형식의 불변자는 하위형식에서 보존됨
- 히스토리 규칙

#### 하위형식에서 선행조건을 더할 수 없음
선행조건이란 어떤 코드가 동작하는 조건을 결정한다.
즉, 구현한 코드가 어떻게든 실행될 것이라고 가정할 수 는 없다.

LSP란 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음을 의미한다. 부모가 문서의 크기를 제한하지 않았다면, 문서의 크기가 100KB보다 작아야 한다고 요구 할 수 없다.

#### 하위형식에서 후행조건을 약화시킬 수 없음
후행조건이란 어떤 코드를 실행한 다음에 만족해야 하는 규칙이다.
즉, 부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 한다.

#### 슈퍼형식의 불변자는 하위형식에서 보존됨
불변자란 항상 변하지 않는 어떤 것을 가리킨다.
상속 관계의 부모와 자식클래스가 있을 때, 부모 클래스에서 유지되는 모든 불변자는 자식 클래스에서도 유지되어야 한다.

#### 히스토리 규칙
기본적으로 자식 클래스는 부모가 허용하지 않는 상태 변화를 허용하지 않아야 한다.
만약, 자식이 불변이 아니라면 호출자의 예상을 뒤엎을수도 있다.

### 문서 관리 시스템을 다른 방법으로 설계

#### 임포터를 클래스로 만들기
인터페이스 대신 가장 상위에 Importer 클래스를 만드는 방법

인터페이스와 클래스는 서로 다른 기능을 제공한다.
- 인터페이스 : 여러 개를 한 번에 구현할 수 있음
- 클래스 : 일반 인스턴스 필드와 메서드를 가짐

인터페이스를 이용하는 것이 클래스를 이용하는 것보다 명백하게 좋은 선택이다.

(쉽게 망가질 수 있는 상속 기반의 클래스를 피해야 한다)

모든 상황보다는 문제를 해결하려는 도메인에 상태와 많은
동작이 관련되어 있어 강력한 **is a 관계**를 모델링해야 하는 
상황이라면 클래스 기반의 상속이 더 적절!

#### 영역, 캡슐화 선택하기
패키지 영역 : 기본 영역으로 같은 패키지 안의 클래스만 보거나 접근할 수 있다.
(일종의 은폐 장치)

구현 중인 패키지의 세부 정보를 외부로 노출했다면 리팩터링이 어려워진다. 클래스가 외부로 노출되지 않도록 패키지 영역을 적극적으로 적용하면 내부 설계를 쉽게 바꿀 수 있다.

### 기존 코드 확장과 재사용
소프트웨어는 항상 변한다.

문서 관리 시스템에 더 다양한 문서를 추가하고 싶다.

하나의 코드를 세 개의 임포트에 재사용할 수 있다면 좋을 것이다. 코드를 재사용하려면 먼저 이 코드를 어떤 클래스에 구현한 후 세 가지 방법 중 하나를 택해야 한다.
- 유틸리티 클래스 사용
- 상속 사용
- 도메인 클래스 사용

#### 유틸리티 클래스 사용
가장 간단한 방법으로 ImportUtil 클래스를 만들어 공유해야 하는 기능을 구현한다.

결국은 여러 정적 메서드를 포함해야 한다.

-> 객체 지향 프로그래밍의 지향점과는 거리가 멀다. 

보통 어떤 한 의무나 개념과 상관없는 다양한 코드의 모음으로 귀결된다. 시간이 흐를수록 이는 갓 클래스의 모양을 갖춰간다. 
즉, 여러 의무를 담당하는 한 개의 거대 클래스가 탄생한다.
#### 상속 사용
동작과 개념을 상속을 이용해 연결해 구현할 수 있다. 각각의 임포터가 TextImporter 클래스를 상속받는 방법이다.

TextImporter에서 공통 기능을 구현하고 서브 클래스에서 공통 기능을 재사용한다.

문제점은 실제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다

변화를 추상화하는 것이 더 좋고 일반저긍로 상속 관계로 코드를 재사용하는 것은 좋은 방법이 아니다.
#### 도메인 클래스 사용
도메인 클래스로 텍스트 파일을 모델링하는 방법

기본 개념(TextFile 클래스)을 모델링 한 다음, 기본 개념이 제공하는 메서드를 호출해 다양한 임포터를 만든다.

###### 도메인 클래스 구현
기본 개념을 모델링하는 클래스로 도메인 클래스를 이용하면 유연성을 개선할 수 있다.

도메인 클래스를 이용하면 상속 같이 쉽게 깨질 수 있는 계층을 만들지 않으면서도 코드를 재사용 가능하다.

### 테스트 위생
자동화도니 테스트를 구현하면 소프트웨어 유지보수에 큰 도움이 된다.

자동화된 테스트는 퇴행이 발생하는 범위를 줄이며 어떤 동작이 문제를 일으켰는지 이해할 수 있도록 도와준다.

자동화된 테스트는 자신있게 코드를 리팩터링 할 수 있다.

테스트 유지보수 문제를 해결하기 위해선 **테스트 위생**을 지켜야 한다.

🤔 테스트 위생이란?

테스트 대상 코드베이스뿐 아니라 테스트 코드도 깔끔하게 유지하며 유지보수하고 개선해야 함을 의미한다.


#### 테스트 이름 짓기
테스트 이름을 짓기 전에 아주 명확하고 좋은 이름을 발견하는 상황은 흔지 않다.

테스트 이름을 지을 때 가독성, 유지보수성, 실행할 수 있는 문서의 역할을 고려한다.

테스트 이름은 개념이 나리아 테스트하는 동작을 묘사해야 한다.
-> 동작이 아닌 테스트 중 실행하는 메서드명을 그대로 사용하는 것도 또 다른 안티패턴이다.

테스트 이름 짓기의 모범 규칙
- 도메인 용어 사용
  - 문제 도메인을 설명하거나 응용프로그램에서 문제를 지칭할 때 사용하는 용어를 테스트 이름에 사용한다.
- 자연어 사용
  - 모은 테스트 이름은 일반 문장처럼 쉽게 읽을 수 있어야 한다. 테스트 이름은 항상 어떤 동작을 쉽게 이해할 수 있도록 묘사해야 한다.
- 서술적
  - 코드는 한 번 구현하면 여러번 읽게 된다. 나중에 읽을 수 있도록 애초에 시간을 들여 서술적인 좋은 이름을 붙여야 한다.
#### 구현이 아닌 동작
클래스, 컴포넌트, 시스템 테스틀르 구현할 때 -> 대상의 공개 동작만 테스트한다.

테스트는 객체의 내부 상태나 설계는 고려하지 않고 오직 공개 API 메서드만 이용해 테스트를 수행해야 한다.

#### 좋은 진단
테스트는 실패하지 않으면 소용이 없다.

-> 테스트 실패하지 않으면 테스트가 잘 동작하는지 알 수 없기 때문이다.가

-> 실패에 최적화된 테스트를 구현하는 것이 좋다.
(즉, 테스트가 실패한 이유를 쉽게 이해할 수 있도록 만들어야 한다)

이때, 좋은 진단을 사용한다.

🤔 진단이란?

테스트가 실패했을 때 출력하는 메시지와 정보를 의미한다.

`assertEquals`
`assertTrue` 이 두 어셔션은 메시맂로 결정적 단서를 얻기 힘들다

매처로 컬렉션 크기를 확인하면 자세한 설명 진단이 제공되기 때문에 다른 코드를 추가 구현하지 않고도 실수를 쉽게 파악할 수 있다.

`assertThat(documents, hasSize(0))`

- `document` : 첫 번째 인수로 값을 받는다.
- `hasSize()` : 두 번째 인수로 Matcher를 받는다.

🤔 Matcher란?
값이 어떤 속성과 일치하는지와 관련 딘잔을 캡슐화한다.

`hasSize()` 매처는 Matchers 유틸리티 클래스에서 정적 임포트한 메서드로 컬랙션과 크기가 파라미터의 값과 일치하는지 확인한다.

좋은 진단을 만드는 방법
- 커스텀 어셔션 사용
- Matcher 사용법

#### 오류 상황 테스트

#### 상수


### 총정리
- 문서 관리 시스템을 만드는 방법을 배웟다.
- 다양한 구현 방법에 따른 각각의 장단점을 확인했다.
- 소프트웨어 설계를 결정짓는 여러 원칙을 이해했다.
- 상속 관계에 적용하는 리스코프 치환 원칙을 배웠다.
- 상속이 부적절한 상황을 이해했다.


